# Falco

Falco is an system which detects suspicious activity on the kubernetes cluster and send alerts.

Falco was created by sysdig and then donated ot CNCF. its now a CNCF incubating project.

## Architecture

- Falco uses all the system calls from Application space to kernel space through Linux kernel for the purpose of securing and monitoring system.
- For that Falco uses a kernel module called "Falco-kernel module" to trace all the syscall that are coming to the kernel. since this is an kernel level change, most provider do not allow this. Hence Falco also supports "eBPF" (extended berkeley packer filter). eBPF is mostly allowed by different providers.
- Once syscalls are received "Falco kernel module" sends those to "sysdig Libraries" in the user space for analysis.
- Events are then filtered by "Falco policy engine" in the userspace with the help of pre-defined rules in "Falco Rules".
- If suspicious events are found by the "policy Engine" then sends alerts via different notification channel.

> We will see about Falco Rules later, and how to configure them.
> Read more about sysdig

## how to install Falco

As discussed, Falco need to communicate with host kernel. There are couple of ways we can install Falco.

**Install as a Package**(runs as systemd service):

Advantage is Falco is isolated from K8s, hence in case of compromise, Falco will still able to run.

```sh
# read official docs as the commands changes to down
# then start the service
systemctl start falco
systemctl enable falco
```

**Install as a daemonset**(in K8s cluster):

Advantage is its easy to install and manage

```sh
helm repo add falcosecurity https://falcosecurity.github.io/charts

helm repo update

helm install falco falcosecurity/falco
```

## how to use Falco to detect threats

Step-1: Check Falco is running on the system

```sh
systemctl status falco
```

Step-2: create a pod and check the pod is running

```sh
k run nginx --image=nginx
k get po -o wide
```

Step-3: use to see the logs generated by journelctl

```sh
# this command should be run on the node where the pod is running
# determine the node using -o wide command

# this will log events that are generated by falco service
journalctl -fu falco # -f is continuously print in the screen similar to tail; 

## note: once Step-4 is executed we will see an event here
```

Step-4: perform some suspicious activity such as : exec into the pod's shell, read sensitive file

```sh
k exec -it nginx -- bash
cat /etc/shadow
```

## How to configure Falco

Falco already have default rules implemented.

and that is done on a file called "rules.yaml"

This files contains three type of things: **rules**, **lists** and **macros**.

```yaml
# rules.yaml
# each rule have five mandatory keys
- rule: <Name for the rule>
  desc: <long desc>
  condition: <When to filter events matching the rule>
  output: <Output message to be logged in case of event matching the rule>
  priority: <severity of the event> |DUBUG|INFORMATIONAL|NOTICE|WARNING|ERROR|CRITICAL|ALERT|EMERGENCY
- list: <name of list>
  items: <array of items>
- macro: <name of macro>
  condition: condition # mostly for reusability and readability
```

```yaml
# example
- rule: Detect shell inside a container
  desc: Alert if a shell such as bash is open inside the container
  # only when bash is opened inside a container not on the host
  # container.id and proc.name are sysdig filters
  condition: contianer.id != host and proc.name = bash # container and proc.name in (linux_shell) # here we are referring a list and a macro (but means the same)
  output: Bash shell opened (user=%user.name %container.id)
  priority: WARNING
- list: linux_shell
  items: [bash, zsh, ksh, sh, csh]
- macro: container
  condition: contianer.id != host
```

some common sysdig filters:

- container.id: id of container
- container.image.repository: filter container by name of the image
- proc.name: name of the process
- fd.name: name of the file descriptor
- evt.type: system call by name (OPEN, ACCEPT, CONNECT)
- user.name: name of the user who is performing the action

For more filters: https://falco.org/docs/rules/supported-fields
for more macro: https://falco.org/docs/rules/default-macros

**Now where we can implement all the configuration files available here**?

The main configuration file is **/etc/falco/falco.yaml**

The file location can be confirmed by below commands

```sh
journalctl -fu falco # spits out the configuration file name

systemctl status falco # again gives the command that the service is running /etc/falco/falco.yaml
```

```yaml
#/etc/falco/falco.yaml
## note this is not the entire file, only important bits and pieces are discussed here
## full reference : https://falco.org/docs/configuration

rules_file: # to configure rules, order is important, incase of duplicate rule in the files the last will override all above.
- /etc/falco/falco_rules.yaml # default
- /etc/falco/falco_rules.local.yaml # override any default rules, if you directly update the default file, it will be reverted during upgrade process.
- /etc/falco/k8s_audit_rules.yaml
- /etc/falco/rules.d

json_output: false # by default its text

log_stderr: true # this are logs for falco itself
log_syslog: true # this are logs for falco itself
log_level: info # this are logs for falco itself, not the rules

priority: debug # minimum priority falco will log events, in this case any thing higher than debugged priority will be logged

stdout_output: # if you want falco to log to stdout
  enabled: true
file_output: # write to a separate file
  enabled: true
  filename: /opt/falco/events.txt
program_output: # output to external program
  enabled: true
  program: "jq '{text: .output}' | curl -d @- -X POST https://hooks.slack.com/services/XXX"
http_output: # output to any http endpoint
  enalbed: true
  url: http://some.url/some/path
```

**Default falco rule files**?

```yaml
#/etc/falco/falco_rules.yaml
# as discussed earlier
```

Only thing here is if we update any of the rules file, then reload the systemd service as well. However, Falco recommends a different approach.

**Hot Reloading**: "cat /var/run/falco.pid" contains the process id of falco.

Then issue SIGHUNGUP by issuing `kill -1 $(cat /var/run/falco.pid )` it will restart the falco engine, with out interrupting the service itself.
